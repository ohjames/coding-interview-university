Three Rules 
    1. Dictionary is really a list
    2. Keys are hashed to produce indexes
    3. If at first you don't succeed, try again

Consequences:
    1. Collision: when two keys in a dictionary share same slot
    2. Because collisions move keys away from their natural hash values, key order is sensitive to dictionary history
    3. Lookup algorithm is more complicated than 'hash, truncate, and look'
    4. Not all lookups are created equal
    5. When deleting a key, you need to leave 'dummy' keys
    6. Average dictionary performance is excellent
    7. Because of resizing, dictionary can completely reorder during an otherwise innocent insert
    8. Because an insert can radically reorder a dictionary, key insertion is prohibited during iteration

Take-aways:
    1. Hopefully 'the rules' make more sense and seem less arbritrary
        a. Don't rely on order
        b. Don't insert while iterating
        c. Can't have mutable keys
    2. Dictionaries trade space for time (alternatives to getting more space)
        a. Tuples or namedtuples
        b. Give classes __slots__
    3. If class needs its own __hash__() method you now know how hashes should behave
        a. Scatter bits like crazy
        b. Equal instances must have equal hashes
        c. Must also implement __eq__() method
        d. Make hash and equality quick
    4. Equal values should have equal hashes regardless of their type

Python 3.3 Take-away:
    1. In your objects, assign every possible attribute in __init__()
    2. Same dictionary will have a different order each time you run Python 3.3+ or bugfix release of 2.6, 2.7, 3.1, or 3.2 with -R flag

